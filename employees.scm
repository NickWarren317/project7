(define (hourly f l h r)
    (newline)
    (display "Hourly employee: ")
    (display f)
    (display " ")
    (display l)
    (newline)
    (display "hours worked: ")
    (display h)
    (display ", hourly rate: ")
    (display r)
    (newline)
    (display "earned $")
    (display (hourly-earnings h r))
)

(define (hourly-earnings h r)
    (cond
        ((<= h 40) (* h r))
        ((<= h 50) (+ (* 40 r)(*(- h 40)(* r 1.5))))
        (( > h 50) (+ (* 40 r)(* 10 (* r 1.5))(*(- h 50)(* r 2.0))))
    )
)

(define (salaried f l s)
    (newline)
    (display "Salaried employee: ")
    (display f)
    (display " ")
    (display l)
    (newline)
    (display "weekly salary: ")
    (display s)
    (newline)
    (display "earned ")
    (display s)
)

(define (commission f l m s r)
    (newline)
    (display "Commission employee: ")
    (display f)
    (display " ")
    (display l)
    (newline)
    (display "minimum salary: ")
    (display m)
    (display ", sales amount: ")
    (display s)
    (display ", commission rate: ")
    (display (* r 100))
    (display "%")
    (newline)
    (display "earned $")
    (display (commission-earnings m s r))
)

(define (commission-earnings m s r)
    (if (<= (* s r) m)
        m
        (* s r)
    )

)

(define (read-file name)
    (let ((port (open-input-file name))
         (lines '()))
    (define (read-file-helper port lines)
        (let ((line (read-line port)))
        (if (eof-object? line)
        'done
        (begin (cons line lines)
            (read-file-helper port)))))
    (let((result (read-file-helper port lines)))
         (close-input-port port)
         result)
    ))

(define (read-file filename)
(let ((port (open-input-file filename))
      (lines '()))  
  (define (read-lines port lines)
    (let ((line (read-line port)))
      (if (eof-object? line)
          lines
          (read-lines port (cons line lines))))
  )
  (let ((result (read-lines port lines)))
    (close-input-port port)
    result)
  )
)

(define (count lst)
    (display "There are ")
    (display (length lst))
    (display " employees.")
)
(define (avg lst)
    (display "average payment per employee is $")
    (display (/ (total lst) (length lst)))
)
(define (max lst)
    (define (iter lst max-so-far value)
    ; If the list is empty, return the minimum found so far
    (if (null? lst)
        max-so-far
        ; Compare the current element with the current minimum
        (let (
            (line (parse-string (list-at lst 0))))
            (if (string=? (list-at line 0) "hourly")            
                (set! value (hourly-earnings (string->number (list-at line 3)) (string->number (list-at line 4))))
                (if (string=? (list-at line 0) "salaried")
                    (set! value (string->number (list-at line 3)))
                    (if(string=? (list-at line 0) "commission")
                        (set! value (commission-earnings (string->number(list-at line 3)) (string->number(list-at line 4)) (string->number(list-at line 5))))
                    )))
        ; Update the minimum if the current element is smaller
        (iter (cdr lst) (if (> value max-so-far) value max-so-far) value))
    )
    )
    (print (remove_eq lst (iter lst 0 99)))
)
(define (min lst)
    (define (iter lst min-so-far value)
    ; If the list is empty, return the minimum found so far
    (if (null? lst)
        min-so-far
        ; Compare the current element with the current minimum
        (let (
            (line (parse-string (list-at lst 0))))
            (if (string=? (list-at line 0) "hourly")            
                (set! value (hourly-earnings (string->number (list-at line 3)) (string->number (list-at line 4))))
                (if (string=? (list-at line 0) "salaried")
                    (set! value (string->number (list-at line 3)))
                    (if(string=? (list-at line 0) "commission")
                        (set! value (commission-earnings (string->number(list-at line 3)) (string->number(list-at line 4)) (string->number(list-at line 5))))
                    )))
        ; Update the minimum if the current element is smaller
        (iter (cdr lst) (if (< value min-so-far) value min-so-far) value))
      )
    )
    (print (remove_eq lst (iter lst 999999 99)))
)
(define (total lst)
        (define (total-helper lst value)
            (let (
                  (line (parse-string (list-at lst 0))))
              (if (string=? (list-at line 0) "hourly")
                (set! value (+ value (hourly-earnings (string->number (list-at line 3)) (string->number (list-at line 4)))))
                (if (string=? (list-at line 0) "salaried")
                    (set! value (+ value (string->number (list-at line 3))))
                    (if(string=? (list-at line 0) "commission")
                        (set! value (+ value (commission-earnings (string->number(list-at line 3)) (string->number(list-at line 4)) (string->number(list-at line 5)))))
                    )
                )
              )
              (if (= (length lst) 1)
                    value
                    (total-helper (cdr lst) value)
              )
            )
        )
    (let ((result (total-helper lst 0)))
            result)
)
(define (print lst)
    (define (print-helper lst)
        (let (
        (emp (parse-string (list-at lst 0))))
        (newline)
        (if (string=? (list-at emp 0) "hourly")
            (hourly (list-at emp 1) (list-at emp 2) (string->number (list-at emp 3)) (string->number (list-at emp 4)))
            (if (string=? (list-at emp 0) "salaried")
                (salaried (list-at emp 1) (list-at emp 2) (string->number (list-at emp 3)))
                (if(string=? (list-at emp 0) "commission")
                    (commission (list-at emp 1) (list-at emp 2) (string->number (list-at emp 3)) (string->number (list-at emp 4)) (string->number (list-at emp 5)))
                    (display "ERROR!")
        )))
        
            (if (= (length lst) 1)
            'done
            (print-helper (cdr lst))
            )
        )
    )
    (print-helper lst)
)

(define (remove_gt lst thr)
    (define (predicate elem)
        (let (
        (line (parse-string elem)))
        (if (string=? (list-at line 0) "hourly")
            (< thr (hourly-earnings (string->number (list-at line 3)) (string->number (list-at line 4))))
        (if (string=? (list-at line 0) "salaried")
            (< thr (string->number (list-at line 3)))
        (if(string=? (list-at line 0) "commission")
            (< thr (commission-earnings (string->number(list-at line 3)) (string->number(list-at line 4)) (string->number(list-at line 5))))
        )))))
    (filter predicate lst)
)
(define (remove_ge lst thr)
    (define (predicate elem)
        (let (
        (line (parse-string elem)))
        (if (string=? (list-at line 0) "hourly")
            (<= thr (hourly-earnings (string->number (list-at line 3)) (string->number (list-at line 4))))
        (if (string=? (list-at line 0) "salaried")
            (<= thr (string->number (list-at line 3)))
        (if(string=? (list-at line 0) "commission")
            (<= thr (commission-earnings (string->number(list-at line 3)) (string->number(list-at line 4)) (string->number(list-at line 5))))
        )))))
    (filter predicate lst)
)

(define (remove_ne lst thr)
    (define (predicate elem)
        (let (
        (line (parse-string elem)))
        (if (string=? (list-at line 0) "hourly")
            (not (= thr (hourly-earnings (string->number (list-at line 3)) (string->number (list-at line 4)))))
        (if (string=? (list-at line 0) "salaried")
            (not (= thr (string->number (list-at line 3))))
        (if(string=? (list-at line 0) "commission")
            (not (= thr (commission-earnings (string->number(list-at line 3)) (string->number(list-at line 4)) (string->number(list-at line 5)))))
        )))))
    (filter predicate lst)
)
(define (remove_eq lst thr)
    (define (predicate elem)
        (let (
        (line (parse-string elem)))
        (if (string=? (list-at line 0) "hourly")
            (= thr (hourly-earnings (string->number (list-at line 3)) (string->number (list-at line 4))))
        (if (string=? (list-at line 0) "salaried")
            (= thr (string->number (list-at line 3)))
        (if(string=? (list-at line 0) "commission")
            (= thr (commission-earnings (string->number(list-at line 3)) (string->number(list-at line 4)) (string->number(list-at line 5))))
        )))))
    (filter predicate lst)
)
(define (remove_lt lst thr)
    (define (predicate elem)
    (let (
        (line (parse-string elem)))
        (if (string=? (list-at line 0) "hourly")
            (> thr (hourly-earnings (string->number (list-at line 3)) (string->number (list-at line 4))))
        (if (string=? (list-at line 0) "salaried")
            (> thr (string->number (list-at line 3)))
        (if(string=? (list-at line 0) "commission")
            (> thr (commission-earnings (string->number(list-at line 3)) (string->number(list-at line 4)) (string->number(list-at line 5))))
        )))))
    (filter predicate lst)
)
(define (remove_le lst thr)
    (define (predicate elem)
        (let (
        (line (parse-string elem)))
        (if (string=? (list-at line 0) "hourly")
            (>= thr (hourly-earnings (string->number (list-at line 3)) (string->number (list-at line 4))))
        (if (string=? (list-at line 0) "salaried")
            (>= thr (string->number (list-at line 3)))
        (if(string=? (list-at line 0) "commission")
            (>= thr (commission-earnings (string->number(list-at line 3)) (string->number(list-at line 4)) (string->number(list-at line 5))))
        )))))
    (filter predicate lst)
)

(define (perform . args)
    (cond
        ((=(length args) 1)
            (display "Usage: (perform employee_file action)")
            (newline)
            (display "or")
            (newline)
            (display "Usage: (perform employee_file action operator threshold)")
            (newline)
            (newline)
            (display "Valid actions: count print min max total avg")
            (newline)
            (display "Valid operators: eq ne gt ge lt le")
            'done
        )
        ((=(length args) 2)
            (display (list-at (read-file (list-at args 0)) 0))
            (newline)
            (let ((currList (read-file (list-at args 0))))
                (execute-action (list-at args 1) currList)
            )
        )
        ((=(length args) 3)
            (display "or")
            'done
        )
        ((=(length args) 4)
            (let ((currList (read-file (list-at args 0)))
                  (operator (list-at args 2))
                  (thresh (list-at args 3)))
                (cond 
                ((string=? operator "gt")
                    (execute-action (list-at args 1) (remove_gt currList thresh))
                )
                ((string=? operator "ge")
                    (execute-action (list-at args 1) (remove_ge currList thresh))
                )
                ((string=? operator "ne")
                    (execute-action (list-at args 1) (remove_ne currList thresh))
                 )
                ((string=? operator "eq")
                    (execute-action (list-at args 1) (remove_eq currList thresh))
                )
                ((string=? operator "lt")
                    (execute-action (list-at args 1) (remove_lt currList thresh))
                )
                ((string=? operator "le")
                    (execute-action (list-at args 1) (remove_le currList thresh))
                )
              )
            )
            'done
        )
        (else 
            (display "Invalid Arguments")
            'done
        )
    )
)

(define (execute-action act lst)
    (if(string=? act "print")
        (print lst)
    (if(string=? act "count")
        (count lst)
    (if(string=? act "max")
        (max lst)
    (if(string=? act "min")
        (min lst)
    (if(string=? act "avg")
        (avg lst)
    (if(string=? act "total")
        (total lst)
    ))))))
)

(define (list-at lst index)
(if (= index 0)
    (car lst)
    (list-at (cdr lst) (- index 1))))

(define (parse-string input-string)
    (define (parse-string-helper str start-index current-word result-list)
    (if (>= start-index (string-length str))
        (if (not (string-null? current-word))
            (reverse (cons current-word result-list))
            (reverse result-list))
        (let ((current-char (string-ref str start-index)))
            (if (or (char=? current-char #\space)
                    (char=? current-char #\tab)
                    (char=? current-char #\newline)
                    (char=? current-char #\return))
                (parse-string-helper str (+ start-index 1) "" (cons current-word result-list))
                (parse-string-helper str (+ start-index 1) (string-append current-word (string current-char)) result-list))))
    )
    (parse-string-helper input-string 0 "" '())
)
